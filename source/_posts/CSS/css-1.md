---
title: CSS基础知识 一
tags: 前端 CSS
categories: css
---

# 盒子模型与视觉格式化模型

HTML文档中的每个元素在渲染时都会被描述成一个矩形盒子，盒模型是用来表示元素盒子所占空间大小的模型，为元素生成并根据视觉格式化模型(visual formatting model)进行布局的矩形框。盒子模型是用来处理元素内部属性的,而视觉格式化模型是用来处理盒子摆放的.

<!-- more -->

![CSS布局基础](./CSS布局基础.png)

## 盒子模型基础知识

盒子包括content(内容), padding(内边距), border(边框), margin(外边距)区域

![盒子模型示意图](./盒子模型示意图.png)

盒子content区域的宽高取决于几个因素: 盒子是否显式设置宽高(width/height); 盒子是否包含text或者其他盒子; 盒子是否为表格;

content,padding,border的背景由'background'属性指定; margin的背景总是透明的.

margin,border,padding存在各种定义好的属性和参数,以后再详细介绍.

    W3C标准下：盒总宽/高度 = width/height + padding + border + margin;

    怪异模式下：盒总宽/高度 = width/height + margin = 内容宽/高度 + padding + border + margin;

    CSS3中， box-sizing 默认为 content-box ，即采用W3C标准盒模型，若取值 border-box 则采用怪异模式盒模型。

![盒子模型样例](./盒子模型.png)

## 视觉格式化模型(visual formatting model)

视觉格式化模型是用来处理和在视觉媒体上显示文档时使用的计算规则.

视觉格式化模型会根据CSS盒子模型将文档中的元素转换为一个个盒子,每个盒子的布局由以下因素决定:

* 盒子的尺寸和类型
* 定位方案（positioning scheme）：普通流定位、浮动定位或绝对定位
* 文档树中的其它元素：即当前盒子的子元素或兄弟元素
* 外部信息:如视口尺寸与位置,图片大小等

视觉格式化模型会根据盒子的包含块的边界来渲染盒子.盒子会创建一个包含其后代元素的包含块,但盒子并不由包含块所限制,当盒子的布局跑到包含块外面时称为溢出.

        常见名词定义:
        块: block，一个抽象的概念，一个块在文档流上占据一个独立的区域，块与块之间在垂直方向上按照顺序依次堆叠.
        包含块：containing block，包含其他盒子的块称为包含块,一般来说盒子生成的块就是盒子子元素的包含块.
        块级元素: Block-level elements,元素的 display 为 block、list-item、table 时，该元素将成为块级元素.视觉上呈现为块,竖直排列.每个块级元素生成一个主要的块级盒来包含后代盒和生成的内容,并参与定位.
        块级盒: Block-level box, 由块级元素生成,参数块级格式化上下文(BFC).描述元素和它的父元素与兄弟元素之间的表现.
        块容器盒: Block container box, 只包含其他块级盒,或生成一个行内格式化上下文(IFC),只包含行内盒.描述元素和它后代之间的关系.
        块盒: Block boxes, 同时是块容器盒的块级盒.
        匿名块盒: Anonymous block boxes, 没有名字,不能被css选择符选中.块容器盒只包含块级盒或者行内盒,当两者都存在时,将会创建匿名块盒来包含相邻的行内盒.
        行内级元素：inline-level element，display 为 inline、inline-block、inline-table 的元素称为行内级元素。
        行内级盒: inline-level boxes, 由行内级元素生成,参与行内格式化上下文的创建.
        行内盒:inline box, 一个其内容会参与创建其容器的行内格式化上下文的行内级盒子.
        原子行内级盒子:atomic inline-level box, 内容不参与行内格式化上下文创建的行内级盒子,在同一个IFC中,原子行内级盒子不能被拆分成多行
        匿名行内盒:类似于块盒子，CSS引擎有时候也会自动创建一些行内盒子。这些行内盒子无法被选择符选中，因此是匿名的，它们从父元素那里继承那些可继承的属性，其他属性保持默认值 initial.

![块盒块级盒块容器盒关系](./块盒块级盒块容器盒.png)

![行内级盒](./行内级盒.png)

![匿名行盒](./匿名行盒.png)

在div盒子的内容区域有一串文字,选择器无法选中,出现内容溢出,且从父元素继承颜色属性,这样的一个行内盒称为匿名行内盒.

## 定位体系

1. 常规流, 按照次序定位每个盒子,包括块级盒的块格式化,行内盒的行内格式化,块级盒和行内盒的相对定位.在块格式化上下文中,盒子在垂直方向依次排列;在行内格式化上下文中,盒子水平排列.当CSS的 position 属性为 static 或 relative，并且 float 为 none 时，其布局方式为普通流。

2. 浮动, 盒首先根据常规流布局,然后从常规流中脱离并尽可能地向左向右位移,内容可以布局在浮动周围,一个盒子的 float 值不为 none，并且其 position 为 static 或 relative 时，该盒子为浮动定位。

3. 绝对定位, 盒完全从常规流中脱离并根据包含块来分配位置,如果元素的 position 为 absolute 或 fixed，该元素为绝对定位。

### position 属性

1. static: 常规盒,根据常规流布局,top、right、bottom、left属性不生效
2. relative: 盒子的定位根据常规流计算,接着盒子相对常规位置移动,当盒子相对定位后,盒子后面的盒定位时就当盒子没有移动一样计算.
3. absolute: 盒子的位置由top、right、bottom、left属性指定,这些属性根据盒子的包含块来规定移动.绝对定位盒子脱离文档流,这意味着他们对之后的同胞盒布局没有影响,同时这个盒子不会出现外边距合并
4. fixed: 和absolute类似,除此以外,盒相对某些参照物保持固定

## BFC(Block Formatting Context)-块级格式化上下文

触发条件:

* 根元素或包含根元素的元素
* 浮动元素（元素的 float 不是 none）
* 绝对定位元素（元素的 position 为 absolute 或 fixed）
* 行内块元素（元素的 display 为 inline-block）
* 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）
* 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）
* overflow 值不为 visible 的块元素
* 弹性元素（display为 flex 或 inline-flex元素的直接子元素）
* 网格元素（display为 grid 或 inline-grid 元素的直接子元素）

布局规则:

1. BFC内部的盒子会在垂直方向一个个放置
2. 盒子垂直方向的距离由margin决定,同一个BFC中的两个相邻盒子的margin会发生重叠
3. 每个盒子的左外边缘紧贴包含块的左边缘(从右往左的格式里,则为盒右边缘紧贴包含块右边缘),甚至有浮动也是如此(尽管盒里的行盒可能由于浮动而收缩),除非盒子创建一个新的BFC(这样盒子本身可能由于浮动而变窄)
4. BFC是一个独立的容器,容器内的子元素不会影响到外面的元素
5. 计算BFC高度时,考虑BFC包含的所有子元素,浮动元素也参与计算

应用:

* 避免外边距折叠
* 解决边框塌陷问题
* 避免文字环绕

![BFC布局](./BFC1.png)

BFC内部元素垂直放置,距离由margin决定,同一个BFC中的两个相邻盒子margin会发生重叠,浮动元素也要参与BFC高度计算.

![BFC布局](./BFC2.png)

BFC容器独立,子元素不会影响外部元素.

BFC解决文字环绕问题

![BFC文字环绕](./BFC文字环绕1.png)
![BFC文字环绕](./BFC文字环绕2.png)

BFC解决子元素浮动导致的高度塌陷问题,BFC浮动元素也参与高度计算

![BFC高度塌陷](./BFC高度塌陷1.png)
![BFC高度塌陷](./BFC高度塌陷2.png)

## IFC(Inline Formatting Context)-行内格式化上下文

布局规则:

1. IFC内部的盒子会在水平方向一个个放置
2. 盒子垂直方向的起点从包含块的顶部开始
3. 摆放盒子时,盒水平方向的外边距、边框和内边距在布局时都会考虑在内
4. 垂直方向上,可能以不同方式对齐: 使用顶部或底部对齐,或通过内部文本基线对齐
5. 行盒: Line Box,能把在一行上的盒子都包含进去的一个矩形区域.行盒的宽度由包含块和浮动来定
6. IFC中的行盒一般左右边紧贴包含块,但会因float元素的存在而缩短.
7. IFC中的行盒高度由CSS行高计算规则来确定,同个IFC下的多个行盒高度可能不同
8. 当行内级盒的总宽度小于包含它们的行盒,其水平渲染规则由text-align属性来确定,如果取值为justify,那么浏览器会对行内盒的文字和空格进行拉伸
9. 当行内盒超过行盒的宽度时,它会被分割成多个盒子,这些盒子被分布在多个行盒中,如果行内盒不能被分割,那么这个行内盒会溢出

![IFC布局](./IFC布局.png)

## 外边距折叠(collapsing margins)

相邻的两个盒子的外边距结合为一个单独的外边距,其大小取其中的最大者,这种行为称为外边距折叠.浮动元素和绝对定位元素的外边距不会折叠.

相邻垂直外边距发生折叠,除了以下两种情况:

* 根元素的盒的外边距不折叠
* 如果一个有空隙的元素的上下外边距相邻,其外边距将同其后同胞的相邻外边距折叠,但不同父块的下外边距折叠
* 如果属性min-height非零和height为auto的盒子的上外边距与他文档流中的最后一个子元素的下外边距折叠,则子元素的底外边距不会和父元素的底外边距折叠

水平外边距不会重叠

两个外边距相邻:

* 属于一个块格式化上下文的文档流内的块级盒子
* 没有行盒、空隙、内边距和边框分隔它们（注意某些零高度行盒）
* 盒边缘垂直相邻:
    * 盒子上外边距及其第一个文档流内盒子上外边距
    * 盒子下外边距及下一个文档流内的同级盒子的上外边距
    * 父盒子高度为auto时,文档流内最后一个子盒子的下外边距和它父盒子的下外边距
    * 一个没有生成BFC且min-height为0,height为0或者auto,且文档流中没有子元素的盒子的上下外边距

当两个及以上的外边距折叠,所得边距的宽度是折叠边距宽度的最大值.如果折叠外边距中存在负值,则为最大正数外边距减去最小负数外边距的绝对值.如果折叠外边距都为负数,则为最小负数外边距.

如果一个盒子的上下外边距相邻,则外边距可能穿过盒子而折叠,这种情况下,元素的定位取决于它同其他外边距折叠的元素的关系:
* 如果元素外边框同其父元素的上外边距折叠,则该盒子的上外边框边缘同其父元素的上外边框边缘相同
* 否则，要么该元素的父元素的外边距不折叠，要么只有父元素的下外边距折叠。上边框边缘位置是假定该元素下边框非零时的位置

![外边距合并样例1](./外边距合并样例1.png)

![外边距合并样例2](./外边距合并样例2.png)

![外边距合并样例3](./外边距合并样例3.png)

![外边距合并样例4](./外边距合并样例4.png)

## 相对定位(relative)

普通流定位中的一种,定位元素的位置相对于它在普通流中的位置进行移动,元素依然占据原来的位置,相对移动会导致元素覆盖其他的盒子.

![相对定位](./相对定位.png)

## 浮动(float)

浮动盒会被移动至左侧或右侧,直至其外侧紧贴包含块的边缘或另一个浮动的外边缘,如果存在行盒,浮动盒的顶部外边缘将与行盒顶部对齐,如果水平方向没有足够的空间容纳浮动,它将下移至能够放下它后者没有其他浮动.

## 绝对定位(absolute)

盒子从常规流中完全脱离,位置相对于距离它最近的那个已经定位的祖先元素决定,绝对定位盒子为其常规流子元素和绝对定位后代创建包含块,但绝对定位元素的内容不在其他盒子的流中,绝对定位是否被遮盖取决于重叠盒子的栈级(Stack Level)

![绝对定位](./绝对定位.png)

### 固定定位(fixed)

固定定位盒子的包含块是有视口创建的,当文档滚动时,固定盒子不动.